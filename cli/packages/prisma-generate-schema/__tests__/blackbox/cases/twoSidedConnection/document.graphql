type AggregateAWithA {
  count: Int!
}

type AggregateAWithB {
  count: Int!
}

type AggregateAWithC {
  count: Int!
}

type AggregateAWithIdWithA {
  count: Int!
}

type AggregateAWithIdWithB {
  count: Int!
}

type AggregateAWithIdWithC {
  count: Int!
}

type AggregateAWithoutIdWithA {
  count: Int!
}

type AggregateAWithoutIdWithB {
  count: Int!
}

type AggregateAWithoutIdWithC {
  count: Int!
}

type AggregateBWithA {
  count: Int!
}

type AggregateBWithB {
  count: Int!
}

type AggregateBWithC {
  count: Int!
}

type AggregateBWithIdWithA {
  count: Int!
}

type AggregateBWithIdWithB {
  count: Int!
}

type AggregateBWithIdWithC {
  count: Int!
}

type AggregateBWithoutIdWithA {
  count: Int!
}

type AggregateBWithoutIdWithB {
  count: Int!
}

type AggregateBWithoutIdWithC {
  count: Int!
}

type AggregateCWithA {
  count: Int!
}

type AggregateCWithB {
  count: Int!
}

type AggregateCWithC {
  count: Int!
}

type AggregateCWithIdWithA {
  count: Int!
}

type AggregateCWithIdWithB {
  count: Int!
}

type AggregateCWithIdWithC {
  count: Int!
}

type AggregateCWithoutIdWithA {
  count: Int!
}

type AggregateCWithoutIdWithB {
  count: Int!
}

type AggregateCWithoutIdWithC {
  count: Int!
}

type AWithA {
  removeThisId: ID!
  x: AWithIdWithA!
  y: AWithoutIdWithA!
}

"""
A connection to a list of items.
"""
type AWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithAEdge]!
  aggregate: AggregateAWithA!
}

input AWithACreateInput {
  removeThisId: ID
  x: AWithIdWithACreateOneWithoutXInput!
  y: AWithoutIdWithACreateOneWithoutXInput!
}

input AWithACreateOneWithoutXInput {
  create: AWithACreateWithoutXInput
  connect: AWithAWhereUniqueInput
}

input AWithACreateOneWithoutYInput {
  create: AWithACreateWithoutYInput
  connect: AWithAWhereUniqueInput
}

input AWithACreateWithoutXInput {
  removeThisId: ID
  y: AWithoutIdWithACreateOneWithoutXInput!
}

input AWithACreateWithoutYInput {
  removeThisId: ID
  x: AWithIdWithACreateOneWithoutXInput!
}

"""
An edge in a connection.
"""
type AWithAEdge {
  """
  The item at the end of the edge.
  """
  node: AWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithAOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
}

type AWithAPreviousValues {
  removeThisId: ID!
}

type AWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithA
  updatedFields: [String!]
  previousValues: AWithAPreviousValues
}

input AWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithAWhereInput
}

input AWithAUpdateInput {
  x: AWithIdWithAUpdateOneRequiredWithoutXInput
  y: AWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithAUpdateOneRequiredWithoutXInput {
  create: AWithACreateWithoutXInput
  connect: AWithAWhereUniqueInput
  update: AWithAUpdateWithoutXDataInput
  upsert: AWithAUpsertWithoutXInput
}

input AWithAUpdateOneRequiredWithoutYInput {
  create: AWithACreateWithoutYInput
  connect: AWithAWhereUniqueInput
  update: AWithAUpdateWithoutYDataInput
  upsert: AWithAUpsertWithoutYInput
}

input AWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithAUpdateWithoutYDataInput {
  x: AWithIdWithAUpdateOneRequiredWithoutXInput
}

input AWithAUpsertWithoutXInput {
  update: AWithAUpdateWithoutXDataInput!
  create: AWithACreateWithoutXInput!
}

input AWithAUpsertWithoutYInput {
  update: AWithAUpdateWithoutYDataInput!
  create: AWithACreateWithoutYInput!
}

input AWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithAWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  x: AWithIdWithAWhereInput
  y: AWithoutIdWithAWhereInput
}

input AWithAWhereUniqueInput {
  removeThisId: ID
}

type AWithB {
  removeThisId: ID!
  x: BWithIdWithA!
  y: BWithoutIdWithA!
}

"""
A connection to a list of items.
"""
type AWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithBEdge]!
  aggregate: AggregateAWithB!
}

input AWithBCreateInput {
  removeThisId: ID
  x: BWithIdWithACreateOneWithoutXInput!
  y: BWithoutIdWithACreateOneWithoutXInput!
}

input AWithBCreateOneWithoutXInput {
  create: AWithBCreateWithoutXInput
  connect: AWithBWhereUniqueInput
}

input AWithBCreateOneWithoutYInput {
  create: AWithBCreateWithoutYInput
  connect: AWithBWhereUniqueInput
}

input AWithBCreateWithoutXInput {
  removeThisId: ID
  y: BWithoutIdWithACreateOneWithoutXInput!
}

input AWithBCreateWithoutYInput {
  removeThisId: ID
  x: BWithIdWithACreateOneWithoutXInput!
}

"""
An edge in a connection.
"""
type AWithBEdge {
  """
  The item at the end of the edge.
  """
  node: AWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithBOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
}

type AWithBPreviousValues {
  removeThisId: ID!
}

type AWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithB
  updatedFields: [String!]
  previousValues: AWithBPreviousValues
}

input AWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithBWhereInput
}

input AWithBUpdateInput {
  x: BWithIdWithAUpdateOneRequiredWithoutXInput
  y: BWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithBUpdateOneWithoutXInput {
  create: AWithBCreateWithoutXInput
  connect: AWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AWithBUpdateWithoutXDataInput
  upsert: AWithBUpsertWithoutXInput
}

input AWithBUpdateOneWithoutYInput {
  create: AWithBCreateWithoutYInput
  connect: AWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AWithBUpdateWithoutYDataInput
  upsert: AWithBUpsertWithoutYInput
}

input AWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithBUpdateWithoutYDataInput {
  x: BWithIdWithAUpdateOneRequiredWithoutXInput
}

input AWithBUpsertWithoutXInput {
  update: AWithBUpdateWithoutXDataInput!
  create: AWithBCreateWithoutXInput!
}

input AWithBUpsertWithoutYInput {
  update: AWithBUpdateWithoutYDataInput!
  create: AWithBCreateWithoutYInput!
}

input AWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithBWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  x: BWithIdWithAWhereInput
  y: BWithoutIdWithAWhereInput
}

input AWithBWhereUniqueInput {
  removeThisId: ID
}

type AWithC {
  removeThisId: ID!
  x: CWithIdWithA!
  y: CWithoutIdWithA!
}

"""
A connection to a list of items.
"""
type AWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithCEdge]!
  aggregate: AggregateAWithC!
}

input AWithCCreateInput {
  removeThisId: ID
  x: CWithIdWithACreateOneWithoutXInput!
  y: CWithoutIdWithACreateOneWithoutXInput!
}

input AWithCCreateManyWithoutXInput {
  create: [AWithCCreateWithoutXInput!]
  connect: [AWithCWhereUniqueInput!]
}

input AWithCCreateManyWithoutYInput {
  create: [AWithCCreateWithoutYInput!]
  connect: [AWithCWhereUniqueInput!]
}

input AWithCCreateWithoutXInput {
  removeThisId: ID
  y: CWithoutIdWithACreateOneWithoutXInput!
}

input AWithCCreateWithoutYInput {
  removeThisId: ID
  x: CWithIdWithACreateOneWithoutXInput!
}

"""
An edge in a connection.
"""
type AWithCEdge {
  """
  The item at the end of the edge.
  """
  node: AWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithCOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
}

type AWithCPreviousValues {
  removeThisId: ID!
}

input AWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithCScalarWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
}

type AWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithC
  updatedFields: [String!]
  previousValues: AWithCPreviousValues
}

input AWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithCWhereInput
}

input AWithCUpdateInput {
  x: CWithIdWithAUpdateOneRequiredWithoutXInput
  y: CWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithCUpdateManyWithoutXInput {
  create: [AWithCCreateWithoutXInput!]
  connect: [AWithCWhereUniqueInput!]
  set: [AWithCWhereUniqueInput!]
  disconnect: [AWithCWhereUniqueInput!]
  delete: [AWithCWhereUniqueInput!]
  update: [AWithCUpdateWithWhereUniqueWithoutXInput!]
  deleteMany: [AWithCScalarWhereInput!]
  upsert: [AWithCUpsertWithWhereUniqueWithoutXInput!]
}

input AWithCUpdateManyWithoutYInput {
  create: [AWithCCreateWithoutYInput!]
  connect: [AWithCWhereUniqueInput!]
  set: [AWithCWhereUniqueInput!]
  disconnect: [AWithCWhereUniqueInput!]
  delete: [AWithCWhereUniqueInput!]
  update: [AWithCUpdateWithWhereUniqueWithoutYInput!]
  deleteMany: [AWithCScalarWhereInput!]
  upsert: [AWithCUpsertWithWhereUniqueWithoutYInput!]
}

input AWithCUpdateWithoutXDataInput {
  y: CWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithCUpdateWithoutYDataInput {
  x: CWithIdWithAUpdateOneRequiredWithoutXInput
}

input AWithCUpdateWithWhereUniqueWithoutXInput {
  where: AWithCWhereUniqueInput!
  data: AWithCUpdateWithoutXDataInput!
}

input AWithCUpdateWithWhereUniqueWithoutYInput {
  where: AWithCWhereUniqueInput!
  data: AWithCUpdateWithoutYDataInput!
}

input AWithCUpsertWithWhereUniqueWithoutXInput {
  where: AWithCWhereUniqueInput!
  update: AWithCUpdateWithoutXDataInput!
  create: AWithCCreateWithoutXInput!
}

input AWithCUpsertWithWhereUniqueWithoutYInput {
  where: AWithCWhereUniqueInput!
  update: AWithCUpdateWithoutYDataInput!
  create: AWithCCreateWithoutYInput!
}

input AWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithCWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  x: CWithIdWithAWhereInput
  y: CWithoutIdWithAWhereInput
}

input AWithCWhereUniqueInput {
  removeThisId: ID
}

type AWithIdWithA implements Node {
  id: ID!
  field: String!
  x: AWithA!
}

"""
A connection to a list of items.
"""
type AWithIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithIdWithAEdge]!
  aggregate: AggregateAWithIdWithA!
}

input AWithIdWithACreateInput {
  id: ID
  field: String!
  x: AWithACreateOneWithoutXInput!
}

input AWithIdWithACreateOneWithoutXInput {
  create: AWithIdWithACreateWithoutXInput
  connect: AWithIdWithAWhereUniqueInput
}

input AWithIdWithACreateWithoutXInput {
  id: ID
  field: String!
}

"""
An edge in a connection.
"""
type AWithIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: AWithIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
}

type AWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithA
  updatedFields: [String!]
  previousValues: AWithIdWithAPreviousValues
}

input AWithIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithIdWithAWhereInput
}

input AWithIdWithAUpdateInput {
  field: String
  x: AWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithAUpdateManyMutationInput {
  field: String
}

input AWithIdWithAUpdateOneRequiredWithoutXInput {
  create: AWithIdWithACreateWithoutXInput
  connect: AWithIdWithAWhereUniqueInput
  update: AWithIdWithAUpdateWithoutXDataInput
  upsert: AWithIdWithAUpsertWithoutXInput
}

input AWithIdWithAUpdateWithoutXDataInput {
  field: String
}

input AWithIdWithAUpsertWithoutXInput {
  update: AWithIdWithAUpdateWithoutXDataInput!
  create: AWithIdWithACreateWithoutXInput!
}

input AWithIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithAWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: AWithAWhereInput
}

input AWithIdWithAWhereUniqueInput {
  id: ID
}

type AWithIdWithB implements Node {
  id: ID!
  field: String!
  x: BWithA!
}

"""
A connection to a list of items.
"""
type AWithIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithIdWithBEdge]!
  aggregate: AggregateAWithIdWithB!
}

input AWithIdWithBCreateInput {
  id: ID
  field: String!
  x: BWithACreateOneWithoutXInput!
}

input AWithIdWithBCreateOneWithoutXInput {
  create: AWithIdWithBCreateWithoutXInput
  connect: AWithIdWithBWhereUniqueInput
}

input AWithIdWithBCreateWithoutXInput {
  id: ID
  field: String!
}

"""
An edge in a connection.
"""
type AWithIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: AWithIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
}

type AWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithB
  updatedFields: [String!]
  previousValues: AWithIdWithBPreviousValues
}

input AWithIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithIdWithBWhereInput
}

input AWithIdWithBUpdateInput {
  field: String
  x: BWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithBUpdateManyMutationInput {
  field: String
}

input AWithIdWithBUpdateOneWithoutXInput {
  create: AWithIdWithBCreateWithoutXInput
  connect: AWithIdWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AWithIdWithBUpdateWithoutXDataInput
  upsert: AWithIdWithBUpsertWithoutXInput
}

input AWithIdWithBUpdateWithoutXDataInput {
  field: String
}

input AWithIdWithBUpsertWithoutXInput {
  update: AWithIdWithBUpdateWithoutXDataInput!
  create: AWithIdWithBCreateWithoutXInput!
}

input AWithIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithBWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: BWithAWhereInput
}

input AWithIdWithBWhereUniqueInput {
  id: ID
}

type AWithIdWithC implements Node {
  id: ID!
  field: String!
  x: CWithA!
}

"""
A connection to a list of items.
"""
type AWithIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithIdWithCEdge]!
  aggregate: AggregateAWithIdWithC!
}

input AWithIdWithCCreateInput {
  id: ID
  field: String!
  x: CWithACreateOneWithoutXInput!
}

input AWithIdWithCCreateManyWithoutXInput {
  create: [AWithIdWithCCreateWithoutXInput!]
  connect: [AWithIdWithCWhereUniqueInput!]
}

input AWithIdWithCCreateWithoutXInput {
  id: ID
  field: String!
}

"""
An edge in a connection.
"""
type AWithIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: AWithIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
}

type AWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

input AWithIdWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithIdWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithIdWithCScalarWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
}

type AWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithC
  updatedFields: [String!]
  previousValues: AWithIdWithCPreviousValues
}

input AWithIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithIdWithCWhereInput
}

input AWithIdWithCUpdateInput {
  field: String
  x: CWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithCUpdateManyDataInput {
  field: String
}

input AWithIdWithCUpdateManyMutationInput {
  field: String
}

input AWithIdWithCUpdateManyWithoutXInput {
  create: [AWithIdWithCCreateWithoutXInput!]
  connect: [AWithIdWithCWhereUniqueInput!]
  set: [AWithIdWithCWhereUniqueInput!]
  disconnect: [AWithIdWithCWhereUniqueInput!]
  delete: [AWithIdWithCWhereUniqueInput!]
  update: [AWithIdWithCUpdateWithWhereUniqueWithoutXInput!]
  updateMany: [AWithIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [AWithIdWithCScalarWhereInput!]
  upsert: [AWithIdWithCUpsertWithWhereUniqueWithoutXInput!]
}

input AWithIdWithCUpdateManyWithWhereNestedInput {
  where: AWithIdWithCScalarWhereInput!
  data: AWithIdWithCUpdateManyDataInput!
}

input AWithIdWithCUpdateWithoutXDataInput {
  field: String
}

input AWithIdWithCUpdateWithWhereUniqueWithoutXInput {
  where: AWithIdWithCWhereUniqueInput!
  data: AWithIdWithCUpdateWithoutXDataInput!
}

input AWithIdWithCUpsertWithWhereUniqueWithoutXInput {
  where: AWithIdWithCWhereUniqueInput!
  update: AWithIdWithCUpdateWithoutXDataInput!
  create: AWithIdWithCCreateWithoutXInput!
}

input AWithIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithCWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: CWithAWhereInput
}

input AWithIdWithCWhereUniqueInput {
  id: ID
}

type AWithoutIdWithA {
  removeThisId: ID!
  field: String!
  x: AWithA!
}

"""
A connection to a list of items.
"""
type AWithoutIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithoutIdWithAEdge]!
  aggregate: AggregateAWithoutIdWithA!
}

input AWithoutIdWithACreateInput {
  removeThisId: ID
  field: String!
  x: AWithACreateOneWithoutYInput!
}

input AWithoutIdWithACreateOneWithoutXInput {
  create: AWithoutIdWithACreateWithoutXInput
  connect: AWithoutIdWithAWhereUniqueInput
}

input AWithoutIdWithACreateWithoutXInput {
  removeThisId: ID
  field: String!
}

"""
An edge in a connection.
"""
type AWithoutIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: AWithoutIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithoutIdWithAOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
  field_ASC
  field_DESC
}

type AWithoutIdWithAPreviousValues {
  removeThisId: ID!
  field: String!
}

type AWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithA
  updatedFields: [String!]
  previousValues: AWithoutIdWithAPreviousValues
}

input AWithoutIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithAWhereInput
}

input AWithoutIdWithAUpdateInput {
  field: String
  x: AWithAUpdateOneRequiredWithoutYInput
}

input AWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithAUpdateOneRequiredWithoutXInput {
  create: AWithoutIdWithACreateWithoutXInput
  connect: AWithoutIdWithAWhereUniqueInput
  update: AWithoutIdWithAUpdateWithoutXDataInput
  upsert: AWithoutIdWithAUpsertWithoutXInput
}

input AWithoutIdWithAUpdateWithoutXDataInput {
  field: String
}

input AWithoutIdWithAUpsertWithoutXInput {
  update: AWithoutIdWithAUpdateWithoutXDataInput!
  create: AWithoutIdWithACreateWithoutXInput!
}

input AWithoutIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithAWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: AWithAWhereInput
}

input AWithoutIdWithAWhereUniqueInput {
  removeThisId: ID
}

type AWithoutIdWithB {
  removeThisId: ID!
  field: String!
  x: BWithA!
}

"""
A connection to a list of items.
"""
type AWithoutIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithoutIdWithBEdge]!
  aggregate: AggregateAWithoutIdWithB!
}

input AWithoutIdWithBCreateInput {
  removeThisId: ID
  field: String!
  x: BWithACreateOneWithoutYInput!
}

input AWithoutIdWithBCreateOneWithoutXInput {
  create: AWithoutIdWithBCreateWithoutXInput
  connect: AWithoutIdWithBWhereUniqueInput
}

input AWithoutIdWithBCreateWithoutXInput {
  removeThisId: ID
  field: String!
}

"""
An edge in a connection.
"""
type AWithoutIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: AWithoutIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithoutIdWithBOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
  field_ASC
  field_DESC
}

type AWithoutIdWithBPreviousValues {
  removeThisId: ID!
  field: String!
}

type AWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithB
  updatedFields: [String!]
  previousValues: AWithoutIdWithBPreviousValues
}

input AWithoutIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithBWhereInput
}

input AWithoutIdWithBUpdateInput {
  field: String
  x: BWithAUpdateOneRequiredWithoutYInput
}

input AWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithBUpdateOneWithoutXInput {
  create: AWithoutIdWithBCreateWithoutXInput
  connect: AWithoutIdWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AWithoutIdWithBUpdateWithoutXDataInput
  upsert: AWithoutIdWithBUpsertWithoutXInput
}

input AWithoutIdWithBUpdateWithoutXDataInput {
  field: String
}

input AWithoutIdWithBUpsertWithoutXInput {
  update: AWithoutIdWithBUpdateWithoutXDataInput!
  create: AWithoutIdWithBCreateWithoutXInput!
}

input AWithoutIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithBWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: BWithAWhereInput
}

input AWithoutIdWithBWhereUniqueInput {
  removeThisId: ID
}

type AWithoutIdWithC {
  removeThisId: ID!
  field: String!
  x: CWithA!
}

"""
A connection to a list of items.
"""
type AWithoutIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithoutIdWithCEdge]!
  aggregate: AggregateAWithoutIdWithC!
}

input AWithoutIdWithCCreateInput {
  removeThisId: ID
  field: String!
  x: CWithACreateOneWithoutYInput!
}

input AWithoutIdWithCCreateManyWithoutXInput {
  create: [AWithoutIdWithCCreateWithoutXInput!]
  connect: [AWithoutIdWithCWhereUniqueInput!]
}

input AWithoutIdWithCCreateWithoutXInput {
  removeThisId: ID
  field: String!
}

"""
An edge in a connection.
"""
type AWithoutIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: AWithoutIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithoutIdWithCOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
  field_ASC
  field_DESC
}

type AWithoutIdWithCPreviousValues {
  removeThisId: ID!
  field: String!
}

input AWithoutIdWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithoutIdWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithoutIdWithCScalarWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
}

type AWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithC
  updatedFields: [String!]
  previousValues: AWithoutIdWithCPreviousValues
}

input AWithoutIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithCWhereInput
}

input AWithoutIdWithCUpdateInput {
  field: String
  x: CWithAUpdateOneRequiredWithoutYInput
}

input AWithoutIdWithCUpdateManyDataInput {
  field: String
}

input AWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithCUpdateManyWithoutXInput {
  create: [AWithoutIdWithCCreateWithoutXInput!]
  connect: [AWithoutIdWithCWhereUniqueInput!]
  set: [AWithoutIdWithCWhereUniqueInput!]
  disconnect: [AWithoutIdWithCWhereUniqueInput!]
  delete: [AWithoutIdWithCWhereUniqueInput!]
  update: [AWithoutIdWithCUpdateWithWhereUniqueWithoutXInput!]
  updateMany: [AWithoutIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [AWithoutIdWithCScalarWhereInput!]
  upsert: [AWithoutIdWithCUpsertWithWhereUniqueWithoutXInput!]
}

input AWithoutIdWithCUpdateManyWithWhereNestedInput {
  where: AWithoutIdWithCScalarWhereInput!
  data: AWithoutIdWithCUpdateManyDataInput!
}

input AWithoutIdWithCUpdateWithoutXDataInput {
  field: String
}

input AWithoutIdWithCUpdateWithWhereUniqueWithoutXInput {
  where: AWithoutIdWithCWhereUniqueInput!
  data: AWithoutIdWithCUpdateWithoutXDataInput!
}

input AWithoutIdWithCUpsertWithWhereUniqueWithoutXInput {
  where: AWithoutIdWithCWhereUniqueInput!
  update: AWithoutIdWithCUpdateWithoutXDataInput!
  create: AWithoutIdWithCCreateWithoutXInput!
}

input AWithoutIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithCWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: CWithAWhereInput
}

input AWithoutIdWithCWhereUniqueInput {
  removeThisId: ID
}

type BatchPayload {
  """
  The number of nodes that have been affected by the Batch operation.
  """
  count: Long!
}

type BWithA {
  removeThisId: ID!
  x: AWithIdWithB
  y: AWithoutIdWithB
}

"""
A connection to a list of items.
"""
type BWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithAEdge]!
  aggregate: AggregateBWithA!
}

input BWithACreateInput {
  removeThisId: ID
  x: AWithIdWithBCreateOneWithoutXInput
  y: AWithoutIdWithBCreateOneWithoutXInput
}

input BWithACreateOneWithoutXInput {
  create: BWithACreateWithoutXInput
  connect: BWithAWhereUniqueInput
}

input BWithACreateOneWithoutYInput {
  create: BWithACreateWithoutYInput
  connect: BWithAWhereUniqueInput
}

input BWithACreateWithoutXInput {
  removeThisId: ID
  y: AWithoutIdWithBCreateOneWithoutXInput
}

input BWithACreateWithoutYInput {
  removeThisId: ID
  x: AWithIdWithBCreateOneWithoutXInput
}

"""
An edge in a connection.
"""
type BWithAEdge {
  """
  The item at the end of the edge.
  """
  node: BWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithAOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
}

type BWithAPreviousValues {
  removeThisId: ID!
}

type BWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithA
  updatedFields: [String!]
  previousValues: BWithAPreviousValues
}

input BWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithAWhereInput
}

input BWithAUpdateInput {
  x: AWithIdWithBUpdateOneWithoutXInput
  y: AWithoutIdWithBUpdateOneWithoutXInput
}

input BWithAUpdateOneRequiredWithoutXInput {
  create: BWithACreateWithoutXInput
  connect: BWithAWhereUniqueInput
  update: BWithAUpdateWithoutXDataInput
  upsert: BWithAUpsertWithoutXInput
}

input BWithAUpdateOneRequiredWithoutYInput {
  create: BWithACreateWithoutYInput
  connect: BWithAWhereUniqueInput
  update: BWithAUpdateWithoutYDataInput
  upsert: BWithAUpsertWithoutYInput
}

input BWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithBUpdateOneWithoutXInput
}

input BWithAUpdateWithoutYDataInput {
  x: AWithIdWithBUpdateOneWithoutXInput
}

input BWithAUpsertWithoutXInput {
  update: BWithAUpdateWithoutXDataInput!
  create: BWithACreateWithoutXInput!
}

input BWithAUpsertWithoutYInput {
  update: BWithAUpdateWithoutYDataInput!
  create: BWithACreateWithoutYInput!
}

input BWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithAWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  x: AWithIdWithBWhereInput
  y: AWithoutIdWithBWhereInput
}

input BWithAWhereUniqueInput {
  removeThisId: ID
}

type BWithB {
  removeThisId: ID!
  x: BWithIdWithB
  y: BWithoutIdWithB
}

"""
A connection to a list of items.
"""
type BWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithBEdge]!
  aggregate: AggregateBWithB!
}

input BWithBCreateInput {
  removeThisId: ID
  x: BWithIdWithBCreateOneWithoutXInput
  y: BWithoutIdWithBCreateOneWithoutXInput
}

input BWithBCreateOneWithoutXInput {
  create: BWithBCreateWithoutXInput
  connect: BWithBWhereUniqueInput
}

input BWithBCreateOneWithoutYInput {
  create: BWithBCreateWithoutYInput
  connect: BWithBWhereUniqueInput
}

input BWithBCreateWithoutXInput {
  removeThisId: ID
  y: BWithoutIdWithBCreateOneWithoutXInput
}

input BWithBCreateWithoutYInput {
  removeThisId: ID
  x: BWithIdWithBCreateOneWithoutXInput
}

"""
An edge in a connection.
"""
type BWithBEdge {
  """
  The item at the end of the edge.
  """
  node: BWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithBOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
}

type BWithBPreviousValues {
  removeThisId: ID!
}

type BWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithB
  updatedFields: [String!]
  previousValues: BWithBPreviousValues
}

input BWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithBWhereInput
}

input BWithBUpdateInput {
  x: BWithIdWithBUpdateOneWithoutXInput
  y: BWithoutIdWithBUpdateOneWithoutXInput
}

input BWithBUpdateOneWithoutXInput {
  create: BWithBCreateWithoutXInput
  connect: BWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: BWithBUpdateWithoutXDataInput
  upsert: BWithBUpsertWithoutXInput
}

input BWithBUpdateOneWithoutYInput {
  create: BWithBCreateWithoutYInput
  connect: BWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: BWithBUpdateWithoutYDataInput
  upsert: BWithBUpsertWithoutYInput
}

input BWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithBUpdateOneWithoutXInput
}

input BWithBUpdateWithoutYDataInput {
  x: BWithIdWithBUpdateOneWithoutXInput
}

input BWithBUpsertWithoutXInput {
  update: BWithBUpdateWithoutXDataInput!
  create: BWithBCreateWithoutXInput!
}

input BWithBUpsertWithoutYInput {
  update: BWithBUpdateWithoutYDataInput!
  create: BWithBCreateWithoutYInput!
}

input BWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithBWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  x: BWithIdWithBWhereInput
  y: BWithoutIdWithBWhereInput
}

input BWithBWhereUniqueInput {
  removeThisId: ID
}

type BWithC {
  removeThisId: ID!
  x: CWithIdWithB
  y: CWithoutIdWithB
}

"""
A connection to a list of items.
"""
type BWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithCEdge]!
  aggregate: AggregateBWithC!
}

input BWithCCreateInput {
  removeThisId: ID
  x: CWithIdWithBCreateOneWithoutXInput
  y: CWithoutIdWithBCreateOneWithoutXInput
}

input BWithCCreateManyWithoutXInput {
  create: [BWithCCreateWithoutXInput!]
  connect: [BWithCWhereUniqueInput!]
}

input BWithCCreateManyWithoutYInput {
  create: [BWithCCreateWithoutYInput!]
  connect: [BWithCWhereUniqueInput!]
}

input BWithCCreateWithoutXInput {
  removeThisId: ID
  y: CWithoutIdWithBCreateOneWithoutXInput
}

input BWithCCreateWithoutYInput {
  removeThisId: ID
  x: CWithIdWithBCreateOneWithoutXInput
}

"""
An edge in a connection.
"""
type BWithCEdge {
  """
  The item at the end of the edge.
  """
  node: BWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithCOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
}

type BWithCPreviousValues {
  removeThisId: ID!
}

input BWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithCScalarWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
}

type BWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithC
  updatedFields: [String!]
  previousValues: BWithCPreviousValues
}

input BWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithCWhereInput
}

input BWithCUpdateInput {
  x: CWithIdWithBUpdateOneWithoutXInput
  y: CWithoutIdWithBUpdateOneWithoutXInput
}

input BWithCUpdateManyWithoutXInput {
  create: [BWithCCreateWithoutXInput!]
  connect: [BWithCWhereUniqueInput!]
  set: [BWithCWhereUniqueInput!]
  disconnect: [BWithCWhereUniqueInput!]
  delete: [BWithCWhereUniqueInput!]
  update: [BWithCUpdateWithWhereUniqueWithoutXInput!]
  deleteMany: [BWithCScalarWhereInput!]
  upsert: [BWithCUpsertWithWhereUniqueWithoutXInput!]
}

input BWithCUpdateManyWithoutYInput {
  create: [BWithCCreateWithoutYInput!]
  connect: [BWithCWhereUniqueInput!]
  set: [BWithCWhereUniqueInput!]
  disconnect: [BWithCWhereUniqueInput!]
  delete: [BWithCWhereUniqueInput!]
  update: [BWithCUpdateWithWhereUniqueWithoutYInput!]
  deleteMany: [BWithCScalarWhereInput!]
  upsert: [BWithCUpsertWithWhereUniqueWithoutYInput!]
}

input BWithCUpdateWithoutXDataInput {
  y: CWithoutIdWithBUpdateOneWithoutXInput
}

input BWithCUpdateWithoutYDataInput {
  x: CWithIdWithBUpdateOneWithoutXInput
}

input BWithCUpdateWithWhereUniqueWithoutXInput {
  where: BWithCWhereUniqueInput!
  data: BWithCUpdateWithoutXDataInput!
}

input BWithCUpdateWithWhereUniqueWithoutYInput {
  where: BWithCWhereUniqueInput!
  data: BWithCUpdateWithoutYDataInput!
}

input BWithCUpsertWithWhereUniqueWithoutXInput {
  where: BWithCWhereUniqueInput!
  update: BWithCUpdateWithoutXDataInput!
  create: BWithCCreateWithoutXInput!
}

input BWithCUpsertWithWhereUniqueWithoutYInput {
  where: BWithCWhereUniqueInput!
  update: BWithCUpdateWithoutYDataInput!
  create: BWithCCreateWithoutYInput!
}

input BWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithCWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  x: CWithIdWithBWhereInput
  y: CWithoutIdWithBWhereInput
}

input BWithCWhereUniqueInput {
  removeThisId: ID
}

type BWithIdWithA implements Node {
  id: ID!
  field: String!
  x: AWithB
}

"""
A connection to a list of items.
"""
type BWithIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithIdWithAEdge]!
  aggregate: AggregateBWithIdWithA!
}

input BWithIdWithACreateInput {
  id: ID
  field: String!
  x: AWithBCreateOneWithoutXInput
}

input BWithIdWithACreateOneWithoutXInput {
  create: BWithIdWithACreateWithoutXInput
  connect: BWithIdWithAWhereUniqueInput
}

input BWithIdWithACreateWithoutXInput {
  id: ID
  field: String!
}

"""
An edge in a connection.
"""
type BWithIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: BWithIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
}

type BWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithA
  updatedFields: [String!]
  previousValues: BWithIdWithAPreviousValues
}

input BWithIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithIdWithAWhereInput
}

input BWithIdWithAUpdateInput {
  field: String
  x: AWithBUpdateOneWithoutXInput
}

input BWithIdWithAUpdateManyMutationInput {
  field: String
}

input BWithIdWithAUpdateOneRequiredWithoutXInput {
  create: BWithIdWithACreateWithoutXInput
  connect: BWithIdWithAWhereUniqueInput
  update: BWithIdWithAUpdateWithoutXDataInput
  upsert: BWithIdWithAUpsertWithoutXInput
}

input BWithIdWithAUpdateWithoutXDataInput {
  field: String
}

input BWithIdWithAUpsertWithoutXInput {
  update: BWithIdWithAUpdateWithoutXDataInput!
  create: BWithIdWithACreateWithoutXInput!
}

input BWithIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithAWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: AWithBWhereInput
}

input BWithIdWithAWhereUniqueInput {
  id: ID
}

type BWithIdWithB implements Node {
  id: ID!
  field: String!
  x: BWithB
}

"""
A connection to a list of items.
"""
type BWithIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithIdWithBEdge]!
  aggregate: AggregateBWithIdWithB!
}

input BWithIdWithBCreateInput {
  id: ID
  field: String!
  x: BWithBCreateOneWithoutXInput
}

input BWithIdWithBCreateOneWithoutXInput {
  create: BWithIdWithBCreateWithoutXInput
  connect: BWithIdWithBWhereUniqueInput
}

input BWithIdWithBCreateWithoutXInput {
  id: ID
  field: String!
}

"""
An edge in a connection.
"""
type BWithIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: BWithIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
}

type BWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithB
  updatedFields: [String!]
  previousValues: BWithIdWithBPreviousValues
}

input BWithIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithIdWithBWhereInput
}

input BWithIdWithBUpdateInput {
  field: String
  x: BWithBUpdateOneWithoutXInput
}

input BWithIdWithBUpdateManyMutationInput {
  field: String
}

input BWithIdWithBUpdateOneWithoutXInput {
  create: BWithIdWithBCreateWithoutXInput
  connect: BWithIdWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: BWithIdWithBUpdateWithoutXDataInput
  upsert: BWithIdWithBUpsertWithoutXInput
}

input BWithIdWithBUpdateWithoutXDataInput {
  field: String
}

input BWithIdWithBUpsertWithoutXInput {
  update: BWithIdWithBUpdateWithoutXDataInput!
  create: BWithIdWithBCreateWithoutXInput!
}

input BWithIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithBWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: BWithBWhereInput
}

input BWithIdWithBWhereUniqueInput {
  id: ID
}

type BWithIdWithC implements Node {
  id: ID!
  field: String!
  x: CWithB
}

"""
A connection to a list of items.
"""
type BWithIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithIdWithCEdge]!
  aggregate: AggregateBWithIdWithC!
}

input BWithIdWithCCreateInput {
  id: ID
  field: String!
  x: CWithBCreateOneWithoutXInput
}

input BWithIdWithCCreateManyWithoutXInput {
  create: [BWithIdWithCCreateWithoutXInput!]
  connect: [BWithIdWithCWhereUniqueInput!]
}

input BWithIdWithCCreateWithoutXInput {
  id: ID
  field: String!
}

"""
An edge in a connection.
"""
type BWithIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: BWithIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
}

type BWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

input BWithIdWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithIdWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithIdWithCScalarWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
}

type BWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithC
  updatedFields: [String!]
  previousValues: BWithIdWithCPreviousValues
}

input BWithIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithIdWithCWhereInput
}

input BWithIdWithCUpdateInput {
  field: String
  x: CWithBUpdateOneWithoutXInput
}

input BWithIdWithCUpdateManyDataInput {
  field: String
}

input BWithIdWithCUpdateManyMutationInput {
  field: String
}

input BWithIdWithCUpdateManyWithoutXInput {
  create: [BWithIdWithCCreateWithoutXInput!]
  connect: [BWithIdWithCWhereUniqueInput!]
  set: [BWithIdWithCWhereUniqueInput!]
  disconnect: [BWithIdWithCWhereUniqueInput!]
  delete: [BWithIdWithCWhereUniqueInput!]
  update: [BWithIdWithCUpdateWithWhereUniqueWithoutXInput!]
  updateMany: [BWithIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [BWithIdWithCScalarWhereInput!]
  upsert: [BWithIdWithCUpsertWithWhereUniqueWithoutXInput!]
}

input BWithIdWithCUpdateManyWithWhereNestedInput {
  where: BWithIdWithCScalarWhereInput!
  data: BWithIdWithCUpdateManyDataInput!
}

input BWithIdWithCUpdateWithoutXDataInput {
  field: String
}

input BWithIdWithCUpdateWithWhereUniqueWithoutXInput {
  where: BWithIdWithCWhereUniqueInput!
  data: BWithIdWithCUpdateWithoutXDataInput!
}

input BWithIdWithCUpsertWithWhereUniqueWithoutXInput {
  where: BWithIdWithCWhereUniqueInput!
  update: BWithIdWithCUpdateWithoutXDataInput!
  create: BWithIdWithCCreateWithoutXInput!
}

input BWithIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithCWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: CWithBWhereInput
}

input BWithIdWithCWhereUniqueInput {
  id: ID
}

type BWithoutIdWithA {
  removeThisId: ID!
  field: String!
  x: AWithB
}

"""
A connection to a list of items.
"""
type BWithoutIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithoutIdWithAEdge]!
  aggregate: AggregateBWithoutIdWithA!
}

input BWithoutIdWithACreateInput {
  removeThisId: ID
  field: String!
  x: AWithBCreateOneWithoutYInput
}

input BWithoutIdWithACreateOneWithoutXInput {
  create: BWithoutIdWithACreateWithoutXInput
  connect: BWithoutIdWithAWhereUniqueInput
}

input BWithoutIdWithACreateWithoutXInput {
  removeThisId: ID
  field: String!
}

"""
An edge in a connection.
"""
type BWithoutIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: BWithoutIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithoutIdWithAOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
  field_ASC
  field_DESC
}

type BWithoutIdWithAPreviousValues {
  removeThisId: ID!
  field: String!
}

type BWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithA
  updatedFields: [String!]
  previousValues: BWithoutIdWithAPreviousValues
}

input BWithoutIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithAWhereInput
}

input BWithoutIdWithAUpdateInput {
  field: String
  x: AWithBUpdateOneWithoutYInput
}

input BWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithAUpdateOneRequiredWithoutXInput {
  create: BWithoutIdWithACreateWithoutXInput
  connect: BWithoutIdWithAWhereUniqueInput
  update: BWithoutIdWithAUpdateWithoutXDataInput
  upsert: BWithoutIdWithAUpsertWithoutXInput
}

input BWithoutIdWithAUpdateWithoutXDataInput {
  field: String
}

input BWithoutIdWithAUpsertWithoutXInput {
  update: BWithoutIdWithAUpdateWithoutXDataInput!
  create: BWithoutIdWithACreateWithoutXInput!
}

input BWithoutIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithAWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: AWithBWhereInput
}

input BWithoutIdWithAWhereUniqueInput {
  removeThisId: ID
}

type BWithoutIdWithB {
  removeThisId: ID!
  field: String!
  x: BWithB
}

"""
A connection to a list of items.
"""
type BWithoutIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithoutIdWithBEdge]!
  aggregate: AggregateBWithoutIdWithB!
}

input BWithoutIdWithBCreateInput {
  removeThisId: ID
  field: String!
  x: BWithBCreateOneWithoutYInput
}

input BWithoutIdWithBCreateOneWithoutXInput {
  create: BWithoutIdWithBCreateWithoutXInput
  connect: BWithoutIdWithBWhereUniqueInput
}

input BWithoutIdWithBCreateWithoutXInput {
  removeThisId: ID
  field: String!
}

"""
An edge in a connection.
"""
type BWithoutIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: BWithoutIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithoutIdWithBOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
  field_ASC
  field_DESC
}

type BWithoutIdWithBPreviousValues {
  removeThisId: ID!
  field: String!
}

type BWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithB
  updatedFields: [String!]
  previousValues: BWithoutIdWithBPreviousValues
}

input BWithoutIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithBWhereInput
}

input BWithoutIdWithBUpdateInput {
  field: String
  x: BWithBUpdateOneWithoutYInput
}

input BWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithBUpdateOneWithoutXInput {
  create: BWithoutIdWithBCreateWithoutXInput
  connect: BWithoutIdWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: BWithoutIdWithBUpdateWithoutXDataInput
  upsert: BWithoutIdWithBUpsertWithoutXInput
}

input BWithoutIdWithBUpdateWithoutXDataInput {
  field: String
}

input BWithoutIdWithBUpsertWithoutXInput {
  update: BWithoutIdWithBUpdateWithoutXDataInput!
  create: BWithoutIdWithBCreateWithoutXInput!
}

input BWithoutIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithBWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: BWithBWhereInput
}

input BWithoutIdWithBWhereUniqueInput {
  removeThisId: ID
}

type BWithoutIdWithC {
  removeThisId: ID!
  field: String!
  x: CWithB
}

"""
A connection to a list of items.
"""
type BWithoutIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithoutIdWithCEdge]!
  aggregate: AggregateBWithoutIdWithC!
}

input BWithoutIdWithCCreateInput {
  removeThisId: ID
  field: String!
  x: CWithBCreateOneWithoutYInput
}

input BWithoutIdWithCCreateManyWithoutXInput {
  create: [BWithoutIdWithCCreateWithoutXInput!]
  connect: [BWithoutIdWithCWhereUniqueInput!]
}

input BWithoutIdWithCCreateWithoutXInput {
  removeThisId: ID
  field: String!
}

"""
An edge in a connection.
"""
type BWithoutIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: BWithoutIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithoutIdWithCOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
  field_ASC
  field_DESC
}

type BWithoutIdWithCPreviousValues {
  removeThisId: ID!
  field: String!
}

input BWithoutIdWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithoutIdWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithoutIdWithCScalarWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
}

type BWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithC
  updatedFields: [String!]
  previousValues: BWithoutIdWithCPreviousValues
}

input BWithoutIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithCWhereInput
}

input BWithoutIdWithCUpdateInput {
  field: String
  x: CWithBUpdateOneWithoutYInput
}

input BWithoutIdWithCUpdateManyDataInput {
  field: String
}

input BWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithCUpdateManyWithoutXInput {
  create: [BWithoutIdWithCCreateWithoutXInput!]
  connect: [BWithoutIdWithCWhereUniqueInput!]
  set: [BWithoutIdWithCWhereUniqueInput!]
  disconnect: [BWithoutIdWithCWhereUniqueInput!]
  delete: [BWithoutIdWithCWhereUniqueInput!]
  update: [BWithoutIdWithCUpdateWithWhereUniqueWithoutXInput!]
  updateMany: [BWithoutIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [BWithoutIdWithCScalarWhereInput!]
  upsert: [BWithoutIdWithCUpsertWithWhereUniqueWithoutXInput!]
}

input BWithoutIdWithCUpdateManyWithWhereNestedInput {
  where: BWithoutIdWithCScalarWhereInput!
  data: BWithoutIdWithCUpdateManyDataInput!
}

input BWithoutIdWithCUpdateWithoutXDataInput {
  field: String
}

input BWithoutIdWithCUpdateWithWhereUniqueWithoutXInput {
  where: BWithoutIdWithCWhereUniqueInput!
  data: BWithoutIdWithCUpdateWithoutXDataInput!
}

input BWithoutIdWithCUpsertWithWhereUniqueWithoutXInput {
  where: BWithoutIdWithCWhereUniqueInput!
  update: BWithoutIdWithCUpdateWithoutXDataInput!
  create: BWithoutIdWithCCreateWithoutXInput!
}

input BWithoutIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithCWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: CWithBWhereInput
}

input BWithoutIdWithCWhereUniqueInput {
  removeThisId: ID
}

type CWithA {
  removeThisId: ID!
  x(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithC!]
  y(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithC!]
}

"""
A connection to a list of items.
"""
type CWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithAEdge]!
  aggregate: AggregateCWithA!
}

input CWithACreateInput {
  removeThisId: ID
  x: AWithIdWithCCreateManyWithoutXInput
  y: AWithoutIdWithCCreateManyWithoutXInput
}

input CWithACreateOneWithoutXInput {
  create: CWithACreateWithoutXInput
  connect: CWithAWhereUniqueInput
}

input CWithACreateOneWithoutYInput {
  create: CWithACreateWithoutYInput
  connect: CWithAWhereUniqueInput
}

input CWithACreateWithoutXInput {
  removeThisId: ID
  y: AWithoutIdWithCCreateManyWithoutXInput
}

input CWithACreateWithoutYInput {
  removeThisId: ID
  x: AWithIdWithCCreateManyWithoutXInput
}

"""
An edge in a connection.
"""
type CWithAEdge {
  """
  The item at the end of the edge.
  """
  node: CWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithAOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
}

type CWithAPreviousValues {
  removeThisId: ID!
}

type CWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithA
  updatedFields: [String!]
  previousValues: CWithAPreviousValues
}

input CWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithAWhereInput
}

input CWithAUpdateInput {
  x: AWithIdWithCUpdateManyWithoutXInput
  y: AWithoutIdWithCUpdateManyWithoutXInput
}

input CWithAUpdateOneRequiredWithoutXInput {
  create: CWithACreateWithoutXInput
  connect: CWithAWhereUniqueInput
  update: CWithAUpdateWithoutXDataInput
  upsert: CWithAUpsertWithoutXInput
}

input CWithAUpdateOneRequiredWithoutYInput {
  create: CWithACreateWithoutYInput
  connect: CWithAWhereUniqueInput
  update: CWithAUpdateWithoutYDataInput
  upsert: CWithAUpsertWithoutYInput
}

input CWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithCUpdateManyWithoutXInput
}

input CWithAUpdateWithoutYDataInput {
  x: AWithIdWithCUpdateManyWithoutXInput
}

input CWithAUpsertWithoutXInput {
  update: CWithAUpdateWithoutXDataInput!
  create: CWithACreateWithoutXInput!
}

input CWithAUpsertWithoutYInput {
  update: CWithAUpdateWithoutYDataInput!
  create: CWithACreateWithoutYInput!
}

input CWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithAWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  x_some: AWithIdWithCWhereInput
  y_some: AWithoutIdWithCWhereInput
}

input CWithAWhereUniqueInput {
  removeThisId: ID
}

type CWithB {
  removeThisId: ID!
  x(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithC!]
  y(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithC!]
}

"""
A connection to a list of items.
"""
type CWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithBEdge]!
  aggregate: AggregateCWithB!
}

input CWithBCreateInput {
  removeThisId: ID
  x: BWithIdWithCCreateManyWithoutXInput
  y: BWithoutIdWithCCreateManyWithoutXInput
}

input CWithBCreateOneWithoutXInput {
  create: CWithBCreateWithoutXInput
  connect: CWithBWhereUniqueInput
}

input CWithBCreateOneWithoutYInput {
  create: CWithBCreateWithoutYInput
  connect: CWithBWhereUniqueInput
}

input CWithBCreateWithoutXInput {
  removeThisId: ID
  y: BWithoutIdWithCCreateManyWithoutXInput
}

input CWithBCreateWithoutYInput {
  removeThisId: ID
  x: BWithIdWithCCreateManyWithoutXInput
}

"""
An edge in a connection.
"""
type CWithBEdge {
  """
  The item at the end of the edge.
  """
  node: CWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithBOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
}

type CWithBPreviousValues {
  removeThisId: ID!
}

type CWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithB
  updatedFields: [String!]
  previousValues: CWithBPreviousValues
}

input CWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithBWhereInput
}

input CWithBUpdateInput {
  x: BWithIdWithCUpdateManyWithoutXInput
  y: BWithoutIdWithCUpdateManyWithoutXInput
}

input CWithBUpdateOneWithoutXInput {
  create: CWithBCreateWithoutXInput
  connect: CWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: CWithBUpdateWithoutXDataInput
  upsert: CWithBUpsertWithoutXInput
}

input CWithBUpdateOneWithoutYInput {
  create: CWithBCreateWithoutYInput
  connect: CWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: CWithBUpdateWithoutYDataInput
  upsert: CWithBUpsertWithoutYInput
}

input CWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithCUpdateManyWithoutXInput
}

input CWithBUpdateWithoutYDataInput {
  x: BWithIdWithCUpdateManyWithoutXInput
}

input CWithBUpsertWithoutXInput {
  update: CWithBUpdateWithoutXDataInput!
  create: CWithBCreateWithoutXInput!
}

input CWithBUpsertWithoutYInput {
  update: CWithBUpdateWithoutYDataInput!
  create: CWithBCreateWithoutYInput!
}

input CWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithBWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  x_some: BWithIdWithCWhereInput
  y_some: BWithoutIdWithCWhereInput
}

input CWithBWhereUniqueInput {
  removeThisId: ID
}

type CWithC {
  removeThisId: ID!
  x(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithC!]
  y(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithC!]
}

"""
A connection to a list of items.
"""
type CWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithCEdge]!
  aggregate: AggregateCWithC!
}

input CWithCCreateInput {
  removeThisId: ID
  x: CWithIdWithCCreateManyWithoutXInput
  y: CWithoutIdWithCCreateManyWithoutXInput
}

input CWithCCreateManyWithoutXInput {
  create: [CWithCCreateWithoutXInput!]
  connect: [CWithCWhereUniqueInput!]
}

input CWithCCreateManyWithoutYInput {
  create: [CWithCCreateWithoutYInput!]
  connect: [CWithCWhereUniqueInput!]
}

input CWithCCreateWithoutXInput {
  removeThisId: ID
  y: CWithoutIdWithCCreateManyWithoutXInput
}

input CWithCCreateWithoutYInput {
  removeThisId: ID
  x: CWithIdWithCCreateManyWithoutXInput
}

"""
An edge in a connection.
"""
type CWithCEdge {
  """
  The item at the end of the edge.
  """
  node: CWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithCOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
}

type CWithCPreviousValues {
  removeThisId: ID!
}

input CWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithCScalarWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
}

type CWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithC
  updatedFields: [String!]
  previousValues: CWithCPreviousValues
}

input CWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithCWhereInput
}

input CWithCUpdateInput {
  x: CWithIdWithCUpdateManyWithoutXInput
  y: CWithoutIdWithCUpdateManyWithoutXInput
}

input CWithCUpdateManyWithoutXInput {
  create: [CWithCCreateWithoutXInput!]
  connect: [CWithCWhereUniqueInput!]
  set: [CWithCWhereUniqueInput!]
  disconnect: [CWithCWhereUniqueInput!]
  delete: [CWithCWhereUniqueInput!]
  update: [CWithCUpdateWithWhereUniqueWithoutXInput!]
  deleteMany: [CWithCScalarWhereInput!]
  upsert: [CWithCUpsertWithWhereUniqueWithoutXInput!]
}

input CWithCUpdateManyWithoutYInput {
  create: [CWithCCreateWithoutYInput!]
  connect: [CWithCWhereUniqueInput!]
  set: [CWithCWhereUniqueInput!]
  disconnect: [CWithCWhereUniqueInput!]
  delete: [CWithCWhereUniqueInput!]
  update: [CWithCUpdateWithWhereUniqueWithoutYInput!]
  deleteMany: [CWithCScalarWhereInput!]
  upsert: [CWithCUpsertWithWhereUniqueWithoutYInput!]
}

input CWithCUpdateWithoutXDataInput {
  y: CWithoutIdWithCUpdateManyWithoutXInput
}

input CWithCUpdateWithoutYDataInput {
  x: CWithIdWithCUpdateManyWithoutXInput
}

input CWithCUpdateWithWhereUniqueWithoutXInput {
  where: CWithCWhereUniqueInput!
  data: CWithCUpdateWithoutXDataInput!
}

input CWithCUpdateWithWhereUniqueWithoutYInput {
  where: CWithCWhereUniqueInput!
  data: CWithCUpdateWithoutYDataInput!
}

input CWithCUpsertWithWhereUniqueWithoutXInput {
  where: CWithCWhereUniqueInput!
  update: CWithCUpdateWithoutXDataInput!
  create: CWithCCreateWithoutXInput!
}

input CWithCUpsertWithWhereUniqueWithoutYInput {
  where: CWithCWhereUniqueInput!
  update: CWithCUpdateWithoutYDataInput!
  create: CWithCCreateWithoutYInput!
}

input CWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithCWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  x_some: CWithIdWithCWhereInput
  y_some: CWithoutIdWithCWhereInput
}

input CWithCWhereUniqueInput {
  removeThisId: ID
}

type CWithIdWithA implements Node {
  id: ID!
  field: String!
  x(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC!]
}

"""
A connection to a list of items.
"""
type CWithIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithIdWithAEdge]!
  aggregate: AggregateCWithIdWithA!
}

input CWithIdWithACreateInput {
  id: ID
  field: String!
  x: AWithCCreateManyWithoutXInput
}

input CWithIdWithACreateOneWithoutXInput {
  create: CWithIdWithACreateWithoutXInput
  connect: CWithIdWithAWhereUniqueInput
}

input CWithIdWithACreateWithoutXInput {
  id: ID
  field: String!
}

"""
An edge in a connection.
"""
type CWithIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: CWithIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
}

type CWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithA
  updatedFields: [String!]
  previousValues: CWithIdWithAPreviousValues
}

input CWithIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithIdWithAWhereInput
}

input CWithIdWithAUpdateInput {
  field: String
  x: AWithCUpdateManyWithoutXInput
}

input CWithIdWithAUpdateManyMutationInput {
  field: String
}

input CWithIdWithAUpdateOneRequiredWithoutXInput {
  create: CWithIdWithACreateWithoutXInput
  connect: CWithIdWithAWhereUniqueInput
  update: CWithIdWithAUpdateWithoutXDataInput
  upsert: CWithIdWithAUpsertWithoutXInput
}

input CWithIdWithAUpdateWithoutXDataInput {
  field: String
}

input CWithIdWithAUpsertWithoutXInput {
  update: CWithIdWithAUpdateWithoutXDataInput!
  create: CWithIdWithACreateWithoutXInput!
}

input CWithIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithAWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_some: AWithCWhereInput
}

input CWithIdWithAWhereUniqueInput {
  id: ID
}

type CWithIdWithB implements Node {
  id: ID!
  field: String!
  x(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC!]
}

"""
A connection to a list of items.
"""
type CWithIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithIdWithBEdge]!
  aggregate: AggregateCWithIdWithB!
}

input CWithIdWithBCreateInput {
  id: ID
  field: String!
  x: BWithCCreateManyWithoutXInput
}

input CWithIdWithBCreateOneWithoutXInput {
  create: CWithIdWithBCreateWithoutXInput
  connect: CWithIdWithBWhereUniqueInput
}

input CWithIdWithBCreateWithoutXInput {
  id: ID
  field: String!
}

"""
An edge in a connection.
"""
type CWithIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: CWithIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
}

type CWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithB
  updatedFields: [String!]
  previousValues: CWithIdWithBPreviousValues
}

input CWithIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithIdWithBWhereInput
}

input CWithIdWithBUpdateInput {
  field: String
  x: BWithCUpdateManyWithoutXInput
}

input CWithIdWithBUpdateManyMutationInput {
  field: String
}

input CWithIdWithBUpdateOneWithoutXInput {
  create: CWithIdWithBCreateWithoutXInput
  connect: CWithIdWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: CWithIdWithBUpdateWithoutXDataInput
  upsert: CWithIdWithBUpsertWithoutXInput
}

input CWithIdWithBUpdateWithoutXDataInput {
  field: String
}

input CWithIdWithBUpsertWithoutXInput {
  update: CWithIdWithBUpdateWithoutXDataInput!
  create: CWithIdWithBCreateWithoutXInput!
}

input CWithIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithBWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_some: BWithCWhereInput
}

input CWithIdWithBWhereUniqueInput {
  id: ID
}

type CWithIdWithC implements Node {
  id: ID!
  field: String!
  x(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC!]
}

"""
A connection to a list of items.
"""
type CWithIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithIdWithCEdge]!
  aggregate: AggregateCWithIdWithC!
}

input CWithIdWithCCreateInput {
  id: ID
  field: String!
  x: CWithCCreateManyWithoutXInput
}

input CWithIdWithCCreateManyWithoutXInput {
  create: [CWithIdWithCCreateWithoutXInput!]
  connect: [CWithIdWithCWhereUniqueInput!]
}

input CWithIdWithCCreateWithoutXInput {
  id: ID
  field: String!
}

"""
An edge in a connection.
"""
type CWithIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: CWithIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
}

type CWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

input CWithIdWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithIdWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithIdWithCScalarWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
}

type CWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithC
  updatedFields: [String!]
  previousValues: CWithIdWithCPreviousValues
}

input CWithIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithIdWithCWhereInput
}

input CWithIdWithCUpdateInput {
  field: String
  x: CWithCUpdateManyWithoutXInput
}

input CWithIdWithCUpdateManyDataInput {
  field: String
}

input CWithIdWithCUpdateManyMutationInput {
  field: String
}

input CWithIdWithCUpdateManyWithoutXInput {
  create: [CWithIdWithCCreateWithoutXInput!]
  connect: [CWithIdWithCWhereUniqueInput!]
  set: [CWithIdWithCWhereUniqueInput!]
  disconnect: [CWithIdWithCWhereUniqueInput!]
  delete: [CWithIdWithCWhereUniqueInput!]
  update: [CWithIdWithCUpdateWithWhereUniqueWithoutXInput!]
  updateMany: [CWithIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [CWithIdWithCScalarWhereInput!]
  upsert: [CWithIdWithCUpsertWithWhereUniqueWithoutXInput!]
}

input CWithIdWithCUpdateManyWithWhereNestedInput {
  where: CWithIdWithCScalarWhereInput!
  data: CWithIdWithCUpdateManyDataInput!
}

input CWithIdWithCUpdateWithoutXDataInput {
  field: String
}

input CWithIdWithCUpdateWithWhereUniqueWithoutXInput {
  where: CWithIdWithCWhereUniqueInput!
  data: CWithIdWithCUpdateWithoutXDataInput!
}

input CWithIdWithCUpsertWithWhereUniqueWithoutXInput {
  where: CWithIdWithCWhereUniqueInput!
  update: CWithIdWithCUpdateWithoutXDataInput!
  create: CWithIdWithCCreateWithoutXInput!
}

input CWithIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithCWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_some: CWithCWhereInput
}

input CWithIdWithCWhereUniqueInput {
  id: ID
}

type CWithoutIdWithA {
  removeThisId: ID!
  field: String!
  x(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC!]
}

"""
A connection to a list of items.
"""
type CWithoutIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithoutIdWithAEdge]!
  aggregate: AggregateCWithoutIdWithA!
}

input CWithoutIdWithACreateInput {
  removeThisId: ID
  field: String!
  x: AWithCCreateManyWithoutYInput
}

input CWithoutIdWithACreateOneWithoutXInput {
  create: CWithoutIdWithACreateWithoutXInput
  connect: CWithoutIdWithAWhereUniqueInput
}

input CWithoutIdWithACreateWithoutXInput {
  removeThisId: ID
  field: String!
}

"""
An edge in a connection.
"""
type CWithoutIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: CWithoutIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithoutIdWithAOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
  field_ASC
  field_DESC
}

type CWithoutIdWithAPreviousValues {
  removeThisId: ID!
  field: String!
}

type CWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithA
  updatedFields: [String!]
  previousValues: CWithoutIdWithAPreviousValues
}

input CWithoutIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithAWhereInput
}

input CWithoutIdWithAUpdateInput {
  field: String
  x: AWithCUpdateManyWithoutYInput
}

input CWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithAUpdateOneRequiredWithoutXInput {
  create: CWithoutIdWithACreateWithoutXInput
  connect: CWithoutIdWithAWhereUniqueInput
  update: CWithoutIdWithAUpdateWithoutXDataInput
  upsert: CWithoutIdWithAUpsertWithoutXInput
}

input CWithoutIdWithAUpdateWithoutXDataInput {
  field: String
}

input CWithoutIdWithAUpsertWithoutXInput {
  update: CWithoutIdWithAUpdateWithoutXDataInput!
  create: CWithoutIdWithACreateWithoutXInput!
}

input CWithoutIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithAWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_some: AWithCWhereInput
}

input CWithoutIdWithAWhereUniqueInput {
  removeThisId: ID
}

type CWithoutIdWithB {
  removeThisId: ID!
  field: String!
  x(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC!]
}

"""
A connection to a list of items.
"""
type CWithoutIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithoutIdWithBEdge]!
  aggregate: AggregateCWithoutIdWithB!
}

input CWithoutIdWithBCreateInput {
  removeThisId: ID
  field: String!
  x: BWithCCreateManyWithoutYInput
}

input CWithoutIdWithBCreateOneWithoutXInput {
  create: CWithoutIdWithBCreateWithoutXInput
  connect: CWithoutIdWithBWhereUniqueInput
}

input CWithoutIdWithBCreateWithoutXInput {
  removeThisId: ID
  field: String!
}

"""
An edge in a connection.
"""
type CWithoutIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: CWithoutIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithoutIdWithBOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
  field_ASC
  field_DESC
}

type CWithoutIdWithBPreviousValues {
  removeThisId: ID!
  field: String!
}

type CWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithB
  updatedFields: [String!]
  previousValues: CWithoutIdWithBPreviousValues
}

input CWithoutIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithBWhereInput
}

input CWithoutIdWithBUpdateInput {
  field: String
  x: BWithCUpdateManyWithoutYInput
}

input CWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithBUpdateOneWithoutXInput {
  create: CWithoutIdWithBCreateWithoutXInput
  connect: CWithoutIdWithBWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: CWithoutIdWithBUpdateWithoutXDataInput
  upsert: CWithoutIdWithBUpsertWithoutXInput
}

input CWithoutIdWithBUpdateWithoutXDataInput {
  field: String
}

input CWithoutIdWithBUpsertWithoutXInput {
  update: CWithoutIdWithBUpdateWithoutXDataInput!
  create: CWithoutIdWithBCreateWithoutXInput!
}

input CWithoutIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithBWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_some: BWithCWhereInput
}

input CWithoutIdWithBWhereUniqueInput {
  removeThisId: ID
}

type CWithoutIdWithC {
  removeThisId: ID!
  field: String!
  x(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC!]
}

"""
A connection to a list of items.
"""
type CWithoutIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithoutIdWithCEdge]!
  aggregate: AggregateCWithoutIdWithC!
}

input CWithoutIdWithCCreateInput {
  removeThisId: ID
  field: String!
  x: CWithCCreateManyWithoutYInput
}

input CWithoutIdWithCCreateManyWithoutXInput {
  create: [CWithoutIdWithCCreateWithoutXInput!]
  connect: [CWithoutIdWithCWhereUniqueInput!]
}

input CWithoutIdWithCCreateWithoutXInput {
  removeThisId: ID
  field: String!
}

"""
An edge in a connection.
"""
type CWithoutIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: CWithoutIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithoutIdWithCOrderByInput {
  removeThisId_ASC
  removeThisId_DESC
  field_ASC
  field_DESC
}

type CWithoutIdWithCPreviousValues {
  removeThisId: ID!
  field: String!
}

input CWithoutIdWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithoutIdWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithoutIdWithCScalarWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
}

type CWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithC
  updatedFields: [String!]
  previousValues: CWithoutIdWithCPreviousValues
}

input CWithoutIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithCWhereInput
}

input CWithoutIdWithCUpdateInput {
  field: String
  x: CWithCUpdateManyWithoutYInput
}

input CWithoutIdWithCUpdateManyDataInput {
  field: String
}

input CWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithCUpdateManyWithoutXInput {
  create: [CWithoutIdWithCCreateWithoutXInput!]
  connect: [CWithoutIdWithCWhereUniqueInput!]
  set: [CWithoutIdWithCWhereUniqueInput!]
  disconnect: [CWithoutIdWithCWhereUniqueInput!]
  delete: [CWithoutIdWithCWhereUniqueInput!]
  update: [CWithoutIdWithCUpdateWithWhereUniqueWithoutXInput!]
  updateMany: [CWithoutIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [CWithoutIdWithCScalarWhereInput!]
  upsert: [CWithoutIdWithCUpsertWithWhereUniqueWithoutXInput!]
}

input CWithoutIdWithCUpdateManyWithWhereNestedInput {
  where: CWithoutIdWithCScalarWhereInput!
  data: CWithoutIdWithCUpdateManyDataInput!
}

input CWithoutIdWithCUpdateWithoutXDataInput {
  field: String
}

input CWithoutIdWithCUpdateWithWhereUniqueWithoutXInput {
  where: CWithoutIdWithCWhereUniqueInput!
  data: CWithoutIdWithCUpdateWithoutXDataInput!
}

input CWithoutIdWithCUpsertWithWhereUniqueWithoutXInput {
  where: CWithoutIdWithCWhereUniqueInput!
  update: CWithoutIdWithCUpdateWithoutXDataInput!
  create: CWithoutIdWithCCreateWithoutXInput!
}

input CWithoutIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithCWhereInput!]
  removeThisId: ID
  """
  All values that are not equal to given value.
  """
  removeThisId_not: ID
  """
  All values that are contained in given list.
  """
  removeThisId_in: [ID!]
  """
  All values that are not contained in given list.
  """
  removeThisId_not_in: [ID!]
  """
  All values less than the given value.
  """
  removeThisId_lt: ID
  """
  All values less than or equal the given value.
  """
  removeThisId_lte: ID
  """
  All values greater than the given value.
  """
  removeThisId_gt: ID
  """
  All values greater than or equal the given value.
  """
  removeThisId_gte: ID
  """
  All values containing the given string.
  """
  removeThisId_contains: ID
  """
  All values not containing the given string.
  """
  removeThisId_not_contains: ID
  """
  All values starting with the given string.
  """
  removeThisId_starts_with: ID
  """
  All values not starting with the given string.
  """
  removeThisId_not_starts_with: ID
  """
  All values ending with the given string.
  """
  removeThisId_ends_with: ID
  """
  All values not ending with the given string.
  """
  removeThisId_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_some: CWithCWhereInput
}

input CWithoutIdWithCWhereUniqueInput {
  removeThisId: ID
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Mutation {
  createAWithIdWithA(data: AWithIdWithACreateInput!): AWithIdWithA!
  createAWithoutIdWithA(data: AWithoutIdWithACreateInput!): AWithoutIdWithA!
  createBWithIdWithA(data: BWithIdWithACreateInput!): BWithIdWithA!
  createBWithoutIdWithA(data: BWithoutIdWithACreateInput!): BWithoutIdWithA!
  createCWithIdWithA(data: CWithIdWithACreateInput!): CWithIdWithA!
  createCWithoutIdWithA(data: CWithoutIdWithACreateInput!): CWithoutIdWithA!
  createAWithIdWithB(data: AWithIdWithBCreateInput!): AWithIdWithB!
  createAWithoutIdWithB(data: AWithoutIdWithBCreateInput!): AWithoutIdWithB!
  createBWithIdWithB(data: BWithIdWithBCreateInput!): BWithIdWithB!
  createBWithoutIdWithB(data: BWithoutIdWithBCreateInput!): BWithoutIdWithB!
  createCWithIdWithB(data: CWithIdWithBCreateInput!): CWithIdWithB!
  createCWithoutIdWithB(data: CWithoutIdWithBCreateInput!): CWithoutIdWithB!
  createAWithIdWithC(data: AWithIdWithCCreateInput!): AWithIdWithC!
  createAWithoutIdWithC(data: AWithoutIdWithCCreateInput!): AWithoutIdWithC!
  createBWithIdWithC(data: BWithIdWithCCreateInput!): BWithIdWithC!
  createBWithoutIdWithC(data: BWithoutIdWithCCreateInput!): BWithoutIdWithC!
  createCWithIdWithC(data: CWithIdWithCCreateInput!): CWithIdWithC!
  createCWithoutIdWithC(data: CWithoutIdWithCCreateInput!): CWithoutIdWithC!
  createAWithA(data: AWithACreateInput!): AWithA!
  createAWithB(data: AWithBCreateInput!): AWithB!
  createAWithC(data: AWithCCreateInput!): AWithC!
  createBWithA(data: BWithACreateInput!): BWithA!
  createBWithB(data: BWithBCreateInput!): BWithB!
  createBWithC(data: BWithCCreateInput!): BWithC!
  createCWithA(data: CWithACreateInput!): CWithA!
  createCWithB(data: CWithBCreateInput!): CWithB!
  createCWithC(data: CWithCCreateInput!): CWithC!
  updateAWithIdWithA(data: AWithIdWithAUpdateInput!, where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  updateAWithoutIdWithA(data: AWithoutIdWithAUpdateInput!, where: AWithoutIdWithAWhereUniqueInput!): AWithoutIdWithA
  updateBWithIdWithA(data: BWithIdWithAUpdateInput!, where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  updateBWithoutIdWithA(data: BWithoutIdWithAUpdateInput!, where: BWithoutIdWithAWhereUniqueInput!): BWithoutIdWithA
  updateCWithIdWithA(data: CWithIdWithAUpdateInput!, where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  updateCWithoutIdWithA(data: CWithoutIdWithAUpdateInput!, where: CWithoutIdWithAWhereUniqueInput!): CWithoutIdWithA
  updateAWithIdWithB(data: AWithIdWithBUpdateInput!, where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  updateAWithoutIdWithB(data: AWithoutIdWithBUpdateInput!, where: AWithoutIdWithBWhereUniqueInput!): AWithoutIdWithB
  updateBWithIdWithB(data: BWithIdWithBUpdateInput!, where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  updateBWithoutIdWithB(data: BWithoutIdWithBUpdateInput!, where: BWithoutIdWithBWhereUniqueInput!): BWithoutIdWithB
  updateCWithIdWithB(data: CWithIdWithBUpdateInput!, where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  updateCWithoutIdWithB(data: CWithoutIdWithBUpdateInput!, where: CWithoutIdWithBWhereUniqueInput!): CWithoutIdWithB
  updateAWithIdWithC(data: AWithIdWithCUpdateInput!, where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  updateAWithoutIdWithC(data: AWithoutIdWithCUpdateInput!, where: AWithoutIdWithCWhereUniqueInput!): AWithoutIdWithC
  updateBWithIdWithC(data: BWithIdWithCUpdateInput!, where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  updateBWithoutIdWithC(data: BWithoutIdWithCUpdateInput!, where: BWithoutIdWithCWhereUniqueInput!): BWithoutIdWithC
  updateCWithIdWithC(data: CWithIdWithCUpdateInput!, where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  updateCWithoutIdWithC(data: CWithoutIdWithCUpdateInput!, where: CWithoutIdWithCWhereUniqueInput!): CWithoutIdWithC
  updateAWithA(data: AWithAUpdateInput!, where: AWithAWhereUniqueInput!): AWithA
  updateAWithB(data: AWithBUpdateInput!, where: AWithBWhereUniqueInput!): AWithB
  updateAWithC(data: AWithCUpdateInput!, where: AWithCWhereUniqueInput!): AWithC
  updateBWithA(data: BWithAUpdateInput!, where: BWithAWhereUniqueInput!): BWithA
  updateBWithB(data: BWithBUpdateInput!, where: BWithBWhereUniqueInput!): BWithB
  updateBWithC(data: BWithCUpdateInput!, where: BWithCWhereUniqueInput!): BWithC
  updateCWithA(data: CWithAUpdateInput!, where: CWithAWhereUniqueInput!): CWithA
  updateCWithB(data: CWithBUpdateInput!, where: CWithBWhereUniqueInput!): CWithB
  updateCWithC(data: CWithCUpdateInput!, where: CWithCWhereUniqueInput!): CWithC
  deleteAWithIdWithA(where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  deleteAWithoutIdWithA(where: AWithoutIdWithAWhereUniqueInput!): AWithoutIdWithA
  deleteBWithIdWithA(where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  deleteBWithoutIdWithA(where: BWithoutIdWithAWhereUniqueInput!): BWithoutIdWithA
  deleteCWithIdWithA(where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  deleteCWithoutIdWithA(where: CWithoutIdWithAWhereUniqueInput!): CWithoutIdWithA
  deleteAWithIdWithB(where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  deleteAWithoutIdWithB(where: AWithoutIdWithBWhereUniqueInput!): AWithoutIdWithB
  deleteBWithIdWithB(where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  deleteBWithoutIdWithB(where: BWithoutIdWithBWhereUniqueInput!): BWithoutIdWithB
  deleteCWithIdWithB(where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  deleteCWithoutIdWithB(where: CWithoutIdWithBWhereUniqueInput!): CWithoutIdWithB
  deleteAWithIdWithC(where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  deleteAWithoutIdWithC(where: AWithoutIdWithCWhereUniqueInput!): AWithoutIdWithC
  deleteBWithIdWithC(where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  deleteBWithoutIdWithC(where: BWithoutIdWithCWhereUniqueInput!): BWithoutIdWithC
  deleteCWithIdWithC(where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  deleteCWithoutIdWithC(where: CWithoutIdWithCWhereUniqueInput!): CWithoutIdWithC
  deleteAWithA(where: AWithAWhereUniqueInput!): AWithA
  deleteAWithB(where: AWithBWhereUniqueInput!): AWithB
  deleteAWithC(where: AWithCWhereUniqueInput!): AWithC
  deleteBWithA(where: BWithAWhereUniqueInput!): BWithA
  deleteBWithB(where: BWithBWhereUniqueInput!): BWithB
  deleteBWithC(where: BWithCWhereUniqueInput!): BWithC
  deleteCWithA(where: CWithAWhereUniqueInput!): CWithA
  deleteCWithB(where: CWithBWhereUniqueInput!): CWithB
  deleteCWithC(where: CWithCWhereUniqueInput!): CWithC
  upsertAWithIdWithA(where: AWithIdWithAWhereUniqueInput!, create: AWithIdWithACreateInput!, update: AWithIdWithAUpdateInput!): AWithIdWithA!
  upsertAWithoutIdWithA(where: AWithoutIdWithAWhereUniqueInput!, create: AWithoutIdWithACreateInput!, update: AWithoutIdWithAUpdateInput!): AWithoutIdWithA!
  upsertBWithIdWithA(where: BWithIdWithAWhereUniqueInput!, create: BWithIdWithACreateInput!, update: BWithIdWithAUpdateInput!): BWithIdWithA!
  upsertBWithoutIdWithA(where: BWithoutIdWithAWhereUniqueInput!, create: BWithoutIdWithACreateInput!, update: BWithoutIdWithAUpdateInput!): BWithoutIdWithA!
  upsertCWithIdWithA(where: CWithIdWithAWhereUniqueInput!, create: CWithIdWithACreateInput!, update: CWithIdWithAUpdateInput!): CWithIdWithA!
  upsertCWithoutIdWithA(where: CWithoutIdWithAWhereUniqueInput!, create: CWithoutIdWithACreateInput!, update: CWithoutIdWithAUpdateInput!): CWithoutIdWithA!
  upsertAWithIdWithB(where: AWithIdWithBWhereUniqueInput!, create: AWithIdWithBCreateInput!, update: AWithIdWithBUpdateInput!): AWithIdWithB!
  upsertAWithoutIdWithB(where: AWithoutIdWithBWhereUniqueInput!, create: AWithoutIdWithBCreateInput!, update: AWithoutIdWithBUpdateInput!): AWithoutIdWithB!
  upsertBWithIdWithB(where: BWithIdWithBWhereUniqueInput!, create: BWithIdWithBCreateInput!, update: BWithIdWithBUpdateInput!): BWithIdWithB!
  upsertBWithoutIdWithB(where: BWithoutIdWithBWhereUniqueInput!, create: BWithoutIdWithBCreateInput!, update: BWithoutIdWithBUpdateInput!): BWithoutIdWithB!
  upsertCWithIdWithB(where: CWithIdWithBWhereUniqueInput!, create: CWithIdWithBCreateInput!, update: CWithIdWithBUpdateInput!): CWithIdWithB!
  upsertCWithoutIdWithB(where: CWithoutIdWithBWhereUniqueInput!, create: CWithoutIdWithBCreateInput!, update: CWithoutIdWithBUpdateInput!): CWithoutIdWithB!
  upsertAWithIdWithC(where: AWithIdWithCWhereUniqueInput!, create: AWithIdWithCCreateInput!, update: AWithIdWithCUpdateInput!): AWithIdWithC!
  upsertAWithoutIdWithC(where: AWithoutIdWithCWhereUniqueInput!, create: AWithoutIdWithCCreateInput!, update: AWithoutIdWithCUpdateInput!): AWithoutIdWithC!
  upsertBWithIdWithC(where: BWithIdWithCWhereUniqueInput!, create: BWithIdWithCCreateInput!, update: BWithIdWithCUpdateInput!): BWithIdWithC!
  upsertBWithoutIdWithC(where: BWithoutIdWithCWhereUniqueInput!, create: BWithoutIdWithCCreateInput!, update: BWithoutIdWithCUpdateInput!): BWithoutIdWithC!
  upsertCWithIdWithC(where: CWithIdWithCWhereUniqueInput!, create: CWithIdWithCCreateInput!, update: CWithIdWithCUpdateInput!): CWithIdWithC!
  upsertCWithoutIdWithC(where: CWithoutIdWithCWhereUniqueInput!, create: CWithoutIdWithCCreateInput!, update: CWithoutIdWithCUpdateInput!): CWithoutIdWithC!
  upsertAWithA(where: AWithAWhereUniqueInput!, create: AWithACreateInput!, update: AWithAUpdateInput!): AWithA!
  upsertAWithB(where: AWithBWhereUniqueInput!, create: AWithBCreateInput!, update: AWithBUpdateInput!): AWithB!
  upsertAWithC(where: AWithCWhereUniqueInput!, create: AWithCCreateInput!, update: AWithCUpdateInput!): AWithC!
  upsertBWithA(where: BWithAWhereUniqueInput!, create: BWithACreateInput!, update: BWithAUpdateInput!): BWithA!
  upsertBWithB(where: BWithBWhereUniqueInput!, create: BWithBCreateInput!, update: BWithBUpdateInput!): BWithB!
  upsertBWithC(where: BWithCWhereUniqueInput!, create: BWithCCreateInput!, update: BWithCUpdateInput!): BWithC!
  upsertCWithA(where: CWithAWhereUniqueInput!, create: CWithACreateInput!, update: CWithAUpdateInput!): CWithA!
  upsertCWithB(where: CWithBWhereUniqueInput!, create: CWithBCreateInput!, update: CWithBUpdateInput!): CWithB!
  upsertCWithC(where: CWithCWhereUniqueInput!, create: CWithCCreateInput!, update: CWithCUpdateInput!): CWithC!
  updateManyAWithIdWithAs(data: AWithIdWithAUpdateManyMutationInput!, where: AWithIdWithAWhereInput): BatchPayload!
  updateManyAWithoutIdWithAs(data: AWithoutIdWithAUpdateManyMutationInput!, where: AWithoutIdWithAWhereInput): BatchPayload!
  updateManyBWithIdWithAs(data: BWithIdWithAUpdateManyMutationInput!, where: BWithIdWithAWhereInput): BatchPayload!
  updateManyBWithoutIdWithAs(data: BWithoutIdWithAUpdateManyMutationInput!, where: BWithoutIdWithAWhereInput): BatchPayload!
  updateManyCWithIdWithAs(data: CWithIdWithAUpdateManyMutationInput!, where: CWithIdWithAWhereInput): BatchPayload!
  updateManyCWithoutIdWithAs(data: CWithoutIdWithAUpdateManyMutationInput!, where: CWithoutIdWithAWhereInput): BatchPayload!
  updateManyAWithIdWithBs(data: AWithIdWithBUpdateManyMutationInput!, where: AWithIdWithBWhereInput): BatchPayload!
  updateManyAWithoutIdWithBs(data: AWithoutIdWithBUpdateManyMutationInput!, where: AWithoutIdWithBWhereInput): BatchPayload!
  updateManyBWithIdWithBs(data: BWithIdWithBUpdateManyMutationInput!, where: BWithIdWithBWhereInput): BatchPayload!
  updateManyBWithoutIdWithBs(data: BWithoutIdWithBUpdateManyMutationInput!, where: BWithoutIdWithBWhereInput): BatchPayload!
  updateManyCWithIdWithBs(data: CWithIdWithBUpdateManyMutationInput!, where: CWithIdWithBWhereInput): BatchPayload!
  updateManyCWithoutIdWithBs(data: CWithoutIdWithBUpdateManyMutationInput!, where: CWithoutIdWithBWhereInput): BatchPayload!
  updateManyAWithIdWithCs(data: AWithIdWithCUpdateManyMutationInput!, where: AWithIdWithCWhereInput): BatchPayload!
  updateManyAWithoutIdWithCs(data: AWithoutIdWithCUpdateManyMutationInput!, where: AWithoutIdWithCWhereInput): BatchPayload!
  updateManyBWithIdWithCs(data: BWithIdWithCUpdateManyMutationInput!, where: BWithIdWithCWhereInput): BatchPayload!
  updateManyBWithoutIdWithCs(data: BWithoutIdWithCUpdateManyMutationInput!, where: BWithoutIdWithCWhereInput): BatchPayload!
  updateManyCWithIdWithCs(data: CWithIdWithCUpdateManyMutationInput!, where: CWithIdWithCWhereInput): BatchPayload!
  updateManyCWithoutIdWithCs(data: CWithoutIdWithCUpdateManyMutationInput!, where: CWithoutIdWithCWhereInput): BatchPayload!
  deleteManyAWithIdWithAs(where: AWithIdWithAWhereInput): BatchPayload!
  deleteManyAWithoutIdWithAs(where: AWithoutIdWithAWhereInput): BatchPayload!
  deleteManyBWithIdWithAs(where: BWithIdWithAWhereInput): BatchPayload!
  deleteManyBWithoutIdWithAs(where: BWithoutIdWithAWhereInput): BatchPayload!
  deleteManyCWithIdWithAs(where: CWithIdWithAWhereInput): BatchPayload!
  deleteManyCWithoutIdWithAs(where: CWithoutIdWithAWhereInput): BatchPayload!
  deleteManyAWithIdWithBs(where: AWithIdWithBWhereInput): BatchPayload!
  deleteManyAWithoutIdWithBs(where: AWithoutIdWithBWhereInput): BatchPayload!
  deleteManyBWithIdWithBs(where: BWithIdWithBWhereInput): BatchPayload!
  deleteManyBWithoutIdWithBs(where: BWithoutIdWithBWhereInput): BatchPayload!
  deleteManyCWithIdWithBs(where: CWithIdWithBWhereInput): BatchPayload!
  deleteManyCWithoutIdWithBs(where: CWithoutIdWithBWhereInput): BatchPayload!
  deleteManyAWithIdWithCs(where: AWithIdWithCWhereInput): BatchPayload!
  deleteManyAWithoutIdWithCs(where: AWithoutIdWithCWhereInput): BatchPayload!
  deleteManyBWithIdWithCs(where: BWithIdWithCWhereInput): BatchPayload!
  deleteManyBWithoutIdWithCs(where: BWithoutIdWithCWhereInput): BatchPayload!
  deleteManyCWithIdWithCs(where: CWithIdWithCWhereInput): BatchPayload!
  deleteManyCWithoutIdWithCs(where: CWithoutIdWithCWhereInput): BatchPayload!
  deleteManyAWithAs(where: AWithAWhereInput): BatchPayload!
  deleteManyAWithBs(where: AWithBWhereInput): BatchPayload!
  deleteManyAWithCs(where: AWithCWhereInput): BatchPayload!
  deleteManyBWithAs(where: BWithAWhereInput): BatchPayload!
  deleteManyBWithBs(where: BWithBWhereInput): BatchPayload!
  deleteManyBWithCs(where: BWithCWhereInput): BatchPayload!
  deleteManyCWithAs(where: CWithAWhereInput): BatchPayload!
  deleteManyCWithBs(where: CWithBWhereInput): BatchPayload!
  deleteManyCWithCs(where: CWithCWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""
An object with an ID
"""
interface Node {
  """
  The id of the object.
  """
  id: ID!
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: String
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: String
}

type Query {
  aWithIdWithAs(where: AWithIdWithAWhereInput, orderBy: AWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithA]!
  aWithoutIdWithAs(where: AWithoutIdWithAWhereInput, orderBy: AWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithA]!
  bWithIdWithAs(where: BWithIdWithAWhereInput, orderBy: BWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithA]!
  bWithoutIdWithAs(where: BWithoutIdWithAWhereInput, orderBy: BWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithA]!
  cWithIdWithAs(where: CWithIdWithAWhereInput, orderBy: CWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithA]!
  cWithoutIdWithAs(where: CWithoutIdWithAWhereInput, orderBy: CWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithA]!
  aWithIdWithBs(where: AWithIdWithBWhereInput, orderBy: AWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithB]!
  aWithoutIdWithBs(where: AWithoutIdWithBWhereInput, orderBy: AWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithB]!
  bWithIdWithBs(where: BWithIdWithBWhereInput, orderBy: BWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithB]!
  bWithoutIdWithBs(where: BWithoutIdWithBWhereInput, orderBy: BWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithB]!
  cWithIdWithBs(where: CWithIdWithBWhereInput, orderBy: CWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithB]!
  cWithoutIdWithBs(where: CWithoutIdWithBWhereInput, orderBy: CWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithB]!
  aWithIdWithCs(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithC]!
  aWithoutIdWithCs(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithC]!
  bWithIdWithCs(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithC]!
  bWithoutIdWithCs(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithC]!
  cWithIdWithCs(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithC]!
  cWithoutIdWithCs(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithC]!
  aWithAs(where: AWithAWhereInput, orderBy: AWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithA]!
  aWithBs(where: AWithBWhereInput, orderBy: AWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithB]!
  aWithCs(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC]!
  bWithAs(where: BWithAWhereInput, orderBy: BWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithA]!
  bWithBs(where: BWithBWhereInput, orderBy: BWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithB]!
  bWithCs(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC]!
  cWithAs(where: CWithAWhereInput, orderBy: CWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithA]!
  cWithBs(where: CWithBWhereInput, orderBy: CWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithB]!
  cWithCs(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC]!
  aWithIdWithA(where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  aWithoutIdWithA(where: AWithoutIdWithAWhereUniqueInput!): AWithoutIdWithA
  bWithIdWithA(where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  bWithoutIdWithA(where: BWithoutIdWithAWhereUniqueInput!): BWithoutIdWithA
  cWithIdWithA(where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  cWithoutIdWithA(where: CWithoutIdWithAWhereUniqueInput!): CWithoutIdWithA
  aWithIdWithB(where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  aWithoutIdWithB(where: AWithoutIdWithBWhereUniqueInput!): AWithoutIdWithB
  bWithIdWithB(where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  bWithoutIdWithB(where: BWithoutIdWithBWhereUniqueInput!): BWithoutIdWithB
  cWithIdWithB(where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  cWithoutIdWithB(where: CWithoutIdWithBWhereUniqueInput!): CWithoutIdWithB
  aWithIdWithC(where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  aWithoutIdWithC(where: AWithoutIdWithCWhereUniqueInput!): AWithoutIdWithC
  bWithIdWithC(where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  bWithoutIdWithC(where: BWithoutIdWithCWhereUniqueInput!): BWithoutIdWithC
  cWithIdWithC(where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  cWithoutIdWithC(where: CWithoutIdWithCWhereUniqueInput!): CWithoutIdWithC
  aWithA(where: AWithAWhereUniqueInput!): AWithA
  aWithB(where: AWithBWhereUniqueInput!): AWithB
  aWithC(where: AWithCWhereUniqueInput!): AWithC
  bWithA(where: BWithAWhereUniqueInput!): BWithA
  bWithB(where: BWithBWhereUniqueInput!): BWithB
  bWithC(where: BWithCWhereUniqueInput!): BWithC
  cWithA(where: CWithAWhereUniqueInput!): CWithA
  cWithB(where: CWithBWhereUniqueInput!): CWithB
  cWithC(where: CWithCWhereUniqueInput!): CWithC
  aWithIdWithAsConnection(where: AWithIdWithAWhereInput, orderBy: AWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithAConnection!
  aWithoutIdWithAsConnection(where: AWithoutIdWithAWhereInput, orderBy: AWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithAConnection!
  bWithIdWithAsConnection(where: BWithIdWithAWhereInput, orderBy: BWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithAConnection!
  bWithoutIdWithAsConnection(where: BWithoutIdWithAWhereInput, orderBy: BWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithAConnection!
  cWithIdWithAsConnection(where: CWithIdWithAWhereInput, orderBy: CWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithAConnection!
  cWithoutIdWithAsConnection(where: CWithoutIdWithAWhereInput, orderBy: CWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithAConnection!
  aWithIdWithBsConnection(where: AWithIdWithBWhereInput, orderBy: AWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithBConnection!
  aWithoutIdWithBsConnection(where: AWithoutIdWithBWhereInput, orderBy: AWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithBConnection!
  bWithIdWithBsConnection(where: BWithIdWithBWhereInput, orderBy: BWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithBConnection!
  bWithoutIdWithBsConnection(where: BWithoutIdWithBWhereInput, orderBy: BWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithBConnection!
  cWithIdWithBsConnection(where: CWithIdWithBWhereInput, orderBy: CWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithBConnection!
  cWithoutIdWithBsConnection(where: CWithoutIdWithBWhereInput, orderBy: CWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithBConnection!
  aWithIdWithCsConnection(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithCConnection!
  aWithoutIdWithCsConnection(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithCConnection!
  bWithIdWithCsConnection(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithCConnection!
  bWithoutIdWithCsConnection(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithCConnection!
  cWithIdWithCsConnection(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithCConnection!
  cWithoutIdWithCsConnection(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithCConnection!
  aWithAsConnection(where: AWithAWhereInput, orderBy: AWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithAConnection!
  aWithBsConnection(where: AWithBWhereInput, orderBy: AWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithBConnection!
  aWithCsConnection(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithCConnection!
  bWithAsConnection(where: BWithAWhereInput, orderBy: BWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithAConnection!
  bWithBsConnection(where: BWithBWhereInput, orderBy: BWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithBConnection!
  bWithCsConnection(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithCConnection!
  cWithAsConnection(where: CWithAWhereInput, orderBy: CWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithAConnection!
  cWithBsConnection(where: CWithBWhereInput, orderBy: CWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithBConnection!
  cWithCsConnection(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithCConnection!
  """
  Fetches an object given its ID
  """
  node(
    """
    The ID of an object
    """
    id: ID!
  ): Node
}

type Subscription {
  aWithIdWithA(where: AWithIdWithASubscriptionWhereInput): AWithIdWithASubscriptionPayload
  aWithoutIdWithA(where: AWithoutIdWithASubscriptionWhereInput): AWithoutIdWithASubscriptionPayload
  bWithIdWithA(where: BWithIdWithASubscriptionWhereInput): BWithIdWithASubscriptionPayload
  bWithoutIdWithA(where: BWithoutIdWithASubscriptionWhereInput): BWithoutIdWithASubscriptionPayload
  cWithIdWithA(where: CWithIdWithASubscriptionWhereInput): CWithIdWithASubscriptionPayload
  cWithoutIdWithA(where: CWithoutIdWithASubscriptionWhereInput): CWithoutIdWithASubscriptionPayload
  aWithIdWithB(where: AWithIdWithBSubscriptionWhereInput): AWithIdWithBSubscriptionPayload
  aWithoutIdWithB(where: AWithoutIdWithBSubscriptionWhereInput): AWithoutIdWithBSubscriptionPayload
  bWithIdWithB(where: BWithIdWithBSubscriptionWhereInput): BWithIdWithBSubscriptionPayload
  bWithoutIdWithB(where: BWithoutIdWithBSubscriptionWhereInput): BWithoutIdWithBSubscriptionPayload
  cWithIdWithB(where: CWithIdWithBSubscriptionWhereInput): CWithIdWithBSubscriptionPayload
  cWithoutIdWithB(where: CWithoutIdWithBSubscriptionWhereInput): CWithoutIdWithBSubscriptionPayload
  aWithIdWithC(where: AWithIdWithCSubscriptionWhereInput): AWithIdWithCSubscriptionPayload
  aWithoutIdWithC(where: AWithoutIdWithCSubscriptionWhereInput): AWithoutIdWithCSubscriptionPayload
  bWithIdWithC(where: BWithIdWithCSubscriptionWhereInput): BWithIdWithCSubscriptionPayload
  bWithoutIdWithC(where: BWithoutIdWithCSubscriptionWhereInput): BWithoutIdWithCSubscriptionPayload
  cWithIdWithC(where: CWithIdWithCSubscriptionWhereInput): CWithIdWithCSubscriptionPayload
  cWithoutIdWithC(where: CWithoutIdWithCSubscriptionWhereInput): CWithoutIdWithCSubscriptionPayload
  aWithA(where: AWithASubscriptionWhereInput): AWithASubscriptionPayload
  aWithB(where: AWithBSubscriptionWhereInput): AWithBSubscriptionPayload
  aWithC(where: AWithCSubscriptionWhereInput): AWithCSubscriptionPayload
  bWithA(where: BWithASubscriptionWhereInput): BWithASubscriptionPayload
  bWithB(where: BWithBSubscriptionWhereInput): BWithBSubscriptionPayload
  bWithC(where: BWithCSubscriptionWhereInput): BWithCSubscriptionPayload
  cWithA(where: CWithASubscriptionWhereInput): CWithASubscriptionPayload
  cWithB(where: CWithBSubscriptionWhereInput): CWithBSubscriptionPayload
  cWithC(where: CWithCSubscriptionWhereInput): CWithCSubscriptionPayload
}

